-- day07

/*
    제약조건 추가하기
        
        형식 1 ]
            
            컬럼이름    데이터탕비(길이)
                CONSTRAINT  제약조건이름   PRIMARY KEY
                CONSTRAINT  제약조건이름   REFERENCES  테이블이름(컬럼이름)
                CONSTRAINT  제약조건이름   UNIQUE
                CONSTRAINT  제약조건이름   NOT NULL
                CONSTRAINT  제약조건이름   CHECK (컬럼이름 IN(데이터1, 데이터2, ...))
                
        형식 2 ]
            컬럼이름 데이터타입(길이),
            컬럼이름 데이터타입(길이),
            ...
            CONSTRAINT  제약조건이름   PRIMARY KEY(컬럼이름),
            CONSTRAINT  제약조건이름   UNIQUE(컬럼이름),
            CONSTRAINT  제약조건이름   FOREIGN KEY(컬럼이름), REFERENCES 테이블이름(컬럼이름),
            CONSTRAINT  제약조건이름   CHECK (컬럼이름 IN(데이터1, 데이터2, ...))
            
            주의 ]
                컬럼이 만들어진 이후에는 NOT NULL 제약조건은 추가하지 못한다.
                <== 제약조건을 추가하지 않고 테이블을 만들게 되면
                    컬럼들은 NULL 데이터를 허용하는 컬럼으로 만들어진다.
                    따라서 NOT NULL 제약조건은 이런 컬럼의 속성을 수정해야 한다.
        
        형식 3 ]
            제약조건 없이 테이블을 만드는 경우 테이블 수정명령으로
            제약조건을 추가하는 방법
            
            ALTER TABLE 테이블이름
            ADD CONSTRAINT 제약조건이름   제약조건(컬럼이름)
            ;
*/

CREATE TABLE TMP(
  no NUMBER(2),
  name VARCHAR2(10 CHAR)
);

DESC TMP;

DROP TABLE tmp;

CREATE TABLE avatar(
    ano NUMBER(2),
    aname VARCHAR2(15 CHAR),
    oriname VARCHAR2(50 CHAR),
    savename VARCHAR2(50 CHAR),
    dir VARCHAR2(100 CHAR),
    len NUMBER,
    adate DATE DEFAULT sysdate,
    isshow CHAR(1) DEFAULT 'Y',
    CONSTRAINT AVT_NO_PK PRIMARY KEY(ano),
    CONSTRAINT AVT_SNAME_UK UNIQUE(savename),
    CONSTRAINT AVT_SHOW_CK CHECK(isshow IN('Y', 'N'))
);

-- NOT NULL 제약조건 수정
ALTER TABLE avatar
MODIFY aname
    CONSTRAINT AVT_NAME_NN NOT NULL
;

ALTER TABLE avatar
MODIFY oriname
    CONSTRAINT AVT_ONAME_NN NOT NULL
;

ALTER TABLE avatar
MODIFY savename
    CONSTRAINT AVT_SNAME_NN NOT NULL
;

ALTER TABLE avatar
MODIFY dir
    CONSTRAINT AVT_DIR_NN NOT NULL
;

ALTER TABLE avatar
MODIFY adate
    CONSTRAINT AVT_DATE_NN NOT NULL
;

ALTER TABLE avatar
MODIFY isshow
    CONSTRAINT AVT_SHOW_NN NOT NULL
;

-- 회원테이블 추가
CREATE TABLE MEMBER(
    mno NUMBER(4)
        CONSTRAINT MB_NO_PK PRIMARY KEY,
    name VARCHAR2(20 CHAR)
        CONSTRAINT MB_NAME_NN NOT NULL,
    id VARCHAR2(15 CHAR)
        CONSTRAINT MB_ID_UK UNIQUE
        CONSTRAINT MB_ID_NN NOT NULL,
    pw VARCHAR2(15 CHAR)
        CONSTRAINT MB_PW_NN NOT NULL,
    mail VARCHAR2(50 CHAR)
        CONSTRAINT MB_MAIL_UK UNIQUE
        CONSTRAINT MB_MAIL_NN NOT NULL,
    tel VARCHAR2(13 CHAR)
        CONSTRAINT MB_TEL_UK UNIQUE
        CONSTRAINT MB_TEL_NN NOT NULL,
    avt NUMBER(2) DEFAULT 10
        CONSTRAINT MB_ANO_FK REFERENCES avatar(ano)
        CONSTRAINT MB_ANO_NN NOT NULL,
    gen CHAR(1)
        CONSTRAINT MB_GEN_CK CHECK(gen IN('F', 'M'))
        CONSTRAINT MB_GEN_NN NOT NULL,
    joindate DATE DEFAULT sysdate
        CONSTRAINT MB_DATE_NN NOT NULL,
    isshow CHAR(1) DEFAULT 'Y'
        CONSTRAINT MB_SHOW_CK CHECK(isshow IN('Y', 'N'))
        CONSTRAINT MB_SHOW_NN NOT NULL
); 

/*
    등록된 제약조건 확인하는 방법
    ==> 등록된 제약조건은 오라클이 테이블을 이용해서 관리한다.
        이 테이블이 이름이 USER_CONSTRAINTS 이다.
        
        따라서 이 테이블의 내용을 확인하면 등록된 제약조건을
        확인할 수 있다.
        
        참고 ]
            CONSTRAINT_TYPE
            
                P   - PRIMARY KEY
                R   - FOREIGN KEY
                U   - UNIQUE
                C   - NOT NULL, CHECK
                
--------------------------------------------------------------------------------
    제약조건 삭제하기
        
        형식 ]
            
            ALTER TABLE 테이블이름
            DROP CHSTRAINT 제약조건이름;
        
    참고 ]
        기본키(PRIMARY KEY)의 경우는 제약조건 이름을 몰라도 삭제할 수 있다.
        기본키는 테이블에 오직 한개만 만들어지기 때문
        
        형식 ]
            ALTER TABLE 테이블이름
            DROP PRIMARY KEY;
*/

DESC USER_CONSTRAINTS;

-- 아바타 테이블의 제약조건 조회
SELECT
    constraint_name 제약조건이름, constraint_type 제약조건, table_name 테이블이름
FROM
    user_constraints
WHERE
    table_name IN('AVATAR', 'MEMBER')
;

-- 회원테이블 기본키 제약조건 삭제
ALTER TABLE member
DROP PRIMARY KEY;

-- 기본키 추가
ALTER TABLE member
ADD CONSTRAINT MB_NO_PK PRIMARY KEY(mno);

CREATE TABLE tmp(
    no NUMBER(4)
);

/*
    테이블 수정하기
        1) 필드 추가하기
            
            형식 ]
                ALTER TABLE 테이블이름
                ADD(
                    필드이름    데이터타입(길이)
                        CONSTRAINT 제약조건이름 제약조건
                );

        2) 필드이름 변경하기
            
            형식 ]
                ALTER TABLE 테이블이름
                RENAME COLUMN 필드이름 TO 바뀔이름;
        
    ------------------------------------------------------------------------
        3) 필드 길이 변경하기
        
            형식 ]
                ALTER TABLE 테이블이름
                MODIFY 필드이름 데이터타입(길이);
                
            참고 ]
                -- DEFAULT 값 추가
                ALTER TABLE 테이블이름
                MODIFY 필드이름 DEFAULT 데이터;
                
            *****
            참고 ]
                길이변경은 현재길이보다 늘리는 것은 가능하지만
                줄이는 것은 불가능하다.
                <== 이미 입력 되어있는 데이터가 수정된 길이를 넘어설 수 있기때문에.
                
        4) 필드 삭제하기
            형식 ]
                ALTER TABLE 테이블이름
                DROP COLUMN 필드이름;
    
--------------------------------------------------------------------------------
    
    테이블 이름 변경하기
        
        형식 ]
            
            ALTER TABLE 테이블이름
            RENAME TO 변경될테이블이름;
            
--------------------------------------------------------------------------------

    테이블 삭제하기
        참고 ]
            테이블 내의 모든 데이터도 같이 삭제된다.
        
        형식 1 ]
            DROP TABLE 테이블이름;
            
        형식 2 ]
            DROP TABLE 테이블이름 purge;
            ==> 휴지통에 넣지 말고 완전 삭제하세요.
            
        참고 ]
            DML 명령은 복구가 가능하지만
            DDL 명령은 복구가 원칙적으로 불가능하다.
            
        참고 ]
            10g 부터 휴지통 개념을 추가해서
            삭제된 데이터를 휴지통에 보관하도록 하고 있다.
            
        휴지통 관리 ]
            
            1. 휴지통에 있는 모든 데이터를 완전 지우기
            
                purge recyclebin;
            
            2. 휴지통에 있는 특정 테이블만 완전삭제
            
                purge table 테이블이름;
                
            3. 휴지통 확인하기
                
                show recyclebin ;
                
            4. 휴지통의 테이블 복구하기
                flashowbeak
            
*/ 

-- TMP 테이블에 NAME 필드 추가
ALTER TABLE tmp
ADD(
    name VARCHAR2(10 CHAR)
        CONSTRAINT TMP_NAME_NN NOT NULL
);

-- TMP 테이블의 no 필드에 기본키제약조건 추가
ALTER TABLE tmp
ADD CONSTRAINT TMP_NO_PK PRIMARY KEY(no);

-- NO 를 TNO 로 변경하자
ALTER TABLE tmp
RENAME COLUMN no TO tno;

-- 휴지통 확인
show recyclebin;

--------------------------------------------------------------------------------
/*
    TRUNCATE
    ==> DML 명령중 DELETE 명령과 같이
        테이블 안에 있는 모든 데이터를 삭제시키는 명령
        
    형식 ]
        TRUNCATE TABLE 테이블이름;
        
    참고 ]
        DELETE 명령은 DML 소속이고
        ==> 복구가 가능하다.
        TRUNCATE 명령은 DDL 소속 명령
        ==> 복구가 불가능하다.
        
*/

/*
    무결성 체크
    ==> 데이터 베이스는 프로그램등 전산에서 작업할 때 필요한 데이터를
        제공해주는 보조 프로그램이다.
        따라서 데이터베이스가 가진 데이터는 항상 완벽한 데이터여야 한다.
        그런데 데이터를 입력하는 것은 사람의 몫이고
        따라서 완벽한 데이터를 보장할 수 없게 되었다.
        
        각각의 테이블에 들어가서는 안될 데이터나
        빠지면 안되는 데이터등을 미리 결정해놓고
        데이터를 입력하는 사람이 잘못 입력하면
        그 데이터는 아예 입력되지 못하도록 방지하는 역할을 하는 기능이다.
        
        한마디로 정리하자면
            이상데이터가 입력되는 것을 방지하는 기능
        이다.
        
        따라서 이 기능이 반드시 필요한 기능은 아니다.
        ( ==> 입력하는 사람이 정신 바짝차리고 입력하면 될 일이기 때문에... )
        실수를 미연에 방지할 수 있도록 하는 기능이다.
*/

/*
    참고 ]
        테이블을 생성하는 명령으로
        서브질의의 결과를 이용해서 테이블을 만드는 방법도 있다.
        
        CREATE TABLE 테이블이름
        AS 
            서브질의
        ;
        
        참고 ]
            이렇게 복사하게되면 모든 데이터와 테이블의 구조를 복사할 수 있지만
            not null 제약조건을 제외한 모든 제약조건은
            복사해 오지 않는다.
        
        참고 ]
            이때 복사할 테이블의 구조만 복사하고 싶은 경우
            CREATE TABLE 테이블이름
            AS
                SELECT * FROM 테이블이름 WHERE 1=2;
*/

-- MEMBER 테이블의 모든 내용을 복사해서 MEMB02 테이블을 만들어보자
CREATE TABLE MEMB02
AS
    SELECT * FROM member
;

ALTER TABLE memb02
ADD CONSTRAINT MB02_NO_PK PRIMARY KEY(mno);
